{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, InjectionToken, EventEmitter, forwardRef, ElementRef, Component, ChangeDetectionStrategy, Inject, Optional, Input, Output, ViewChild, ContentChild, NgModule } from '@angular/core';\nimport * as i3 from '@angular/forms';\nimport { FormControl, NG_VALUE_ACCESSOR, ReactiveFormsModule } from '@angular/forms';\nimport * as i11 from '@angular/material/core';\nimport { MatOption } from '@angular/material/core';\nimport * as i12 from '@angular/material/form-field';\nimport { MatFormField } from '@angular/material/form-field';\nimport * as i10 from '@angular/material/select';\nimport { MatSelect } from '@angular/material/select';\nimport { BehaviorSubject, of, combineLatest, Subject } from 'rxjs';\nimport { switchMap, map, startWith, delay, takeUntil, take, tap, filter } from 'rxjs/operators';\nimport * as i1 from '@angular/cdk/scrolling';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i4 from '@angular/material/button';\nimport { MatButtonModule } from '@angular/material/button';\nimport * as i5 from '@angular/material/checkbox';\nimport { MatCheckboxModule } from '@angular/material/checkbox';\nimport * as i6 from '@angular/material/icon';\nimport { MatIconModule } from '@angular/material/icon';\nimport * as i7 from '@angular/material/progress-spinner';\nimport { MatProgressSpinnerModule } from '@angular/material/progress-spinner';\nimport * as i8 from '@angular/material/tooltip';\nimport { MatTooltipModule } from '@angular/material/tooltip';\nimport * as i9 from '@angular/material/divider';\nimport { MatDividerModule } from '@angular/material/divider';\n\n/**\n * Directive for providing a custom clear-icon.\n * e.g.\n * <ngx-mat-select-search [formControl]=\"bankFilterCtrl\">\n *   <mat-icon ngxMatSelectSearchClear>delete</mat-icon>\n * </ngx-mat-select-search>\n */\nconst _c0 = [\"searchSelectInput\"];\nconst _c1 = [\"innerSelectSearch\"];\nconst _c2 = [[[\"\", 8, \"mat-select-search-custom-header-content\"]], [[\"\", \"ngxMatSelectSearchClear\", \"\"]], [[\"\", \"ngxMatSelectNoEntriesFound\", \"\"]]];\nconst _c3 = [\".mat-select-search-custom-header-content\", \"[ngxMatSelectSearchClear]\", \"[ngxMatSelectNoEntriesFound]\"];\nconst _c4 = (a0, a1) => ({\n  \"mat-select-search-inner-multiple\": a0,\n  \"mat-select-search-inner-toggle-all\": a1\n});\nfunction MatSelectSearchComponent_mat_checkbox_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"mat-checkbox\", 12);\n    i0.ɵɵlistener(\"change\", function MatSelectSearchComponent_mat_checkbox_4_Template_mat_checkbox_change_0_listener($event) {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2._emitSelectAllBooleanToParent($event.checked));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"color\", ctx_r2.matFormField == null ? null : ctx_r2.matFormField.color)(\"checked\", ctx_r2.toggleAllCheckboxChecked)(\"indeterminate\", ctx_r2.toggleAllCheckboxIndeterminate)(\"matTooltip\", ctx_r2.toggleAllCheckboxTooltipMessage)(\"matTooltipPosition\", ctx_r2.toggleAllCheckboxTooltipPosition);\n  }\n}\nfunction MatSelectSearchComponent_mat_spinner_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"mat-spinner\", 13);\n  }\n}\nfunction MatSelectSearchComponent_button_8_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngIf\", \"clearIcon; else defaultIcon\"]);\n  }\n}\nfunction MatSelectSearchComponent_button_8_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-icon\", 16);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r2.closeSvgIcon);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", !ctx_r2.closeSvgIcon ? ctx_r2.closeIcon : null, \" \");\n  }\n}\nfunction MatSelectSearchComponent_button_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 14);\n    i0.ɵɵlistener(\"click\", function MatSelectSearchComponent_button_8_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2._reset(true));\n    });\n    i0.ɵɵtemplate(1, MatSelectSearchComponent_button_8_ng_content_1_Template, 1, 0, \"ng-content\", 15)(2, MatSelectSearchComponent_button_8_ng_template_2_Template, 2, 2, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const defaultIcon_r5 = i0.ɵɵreference(3);\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.clearIcon)(\"ngIfElse\", defaultIcon_r5);\n  }\n}\nfunction MatSelectSearchComponent_div_11_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngIf\", \"noEntriesFound; else defaultNoEntriesFound\"]);\n  }\n}\nfunction MatSelectSearchComponent_div_11_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵtextInterpolate(ctx_r2.noEntriesFoundLabel);\n  }\n}\nfunction MatSelectSearchComponent_div_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 17);\n    i0.ɵɵtemplate(1, MatSelectSearchComponent_div_11_ng_content_1_Template, 1, 0, \"ng-content\", 15)(2, MatSelectSearchComponent_div_11_ng_template_2_Template, 1, 1, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const defaultNoEntriesFound_r6 = i0.ɵɵreference(3);\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.noEntriesFound)(\"ngIfElse\", defaultNoEntriesFound_r6);\n  }\n}\nlet MatSelectSearchClearDirective = /*#__PURE__*/(() => {\n  class MatSelectSearchClearDirective {}\n  MatSelectSearchClearDirective.ɵfac = function MatSelectSearchClearDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || MatSelectSearchClearDirective)();\n  };\n  MatSelectSearchClearDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatSelectSearchClearDirective,\n    selectors: [[\"\", \"ngxMatSelectSearchClear\", \"\"]]\n  });\n  return MatSelectSearchClearDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** List of inputs of NgxMatSelectSearchComponent that can be configured with a global default. */\nconst configurableDefaultOptions = ['ariaLabel', 'clearSearchInput', 'closeIcon', 'closeSvgIcon', 'disableInitialFocus', 'disableScrollToActiveOnOptionsChanged', 'enableClearOnEscapePressed', 'hideClearSearchButton', 'noEntriesFoundLabel', 'placeholderLabel', 'preventHomeEndKeyPropagation', 'searching'];\n/**\n * InjectionToken that can be used to specify global options. e.g.\n *\n * ```typescript\n * providers: [\n *   {\n *     provide: MAT_SELECTSEARCH_DEFAULT_OPTIONS,\n *     useValue: <MatSelectSearchOptions>{\n *       closeIcon: 'delete',\n *       noEntriesFoundLabel: 'No options found'\n *     }\n *   }\n * ]\n * ```\n *\n * See the corresponding inputs of `MatSelectSearchComponent` for documentation.\n */\nconst MAT_SELECTSEARCH_DEFAULT_OPTIONS = new InjectionToken('mat-selectsearch-default-options');\n\n/**\n * Directive for providing a custom no entries found element.\n * e.g.\n * <ngx-mat-select-search [formControl]=\"bankFilterCtrl\">\n *   <span ngxMatSelectNoEntriesFound>\n *     No entries found <button>Add</button>\n *   </span>\n * </ngx-mat-select-search>\n */\nlet MatSelectNoEntriesFoundDirective = /*#__PURE__*/(() => {\n  class MatSelectNoEntriesFoundDirective {}\n  MatSelectNoEntriesFoundDirective.ɵfac = function MatSelectNoEntriesFoundDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || MatSelectNoEntriesFoundDirective)();\n  };\n  MatSelectNoEntriesFoundDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatSelectNoEntriesFoundDirective,\n    selectors: [[\"\", \"ngxMatSelectNoEntriesFound\", \"\"]]\n  });\n  return MatSelectNoEntriesFoundDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* tslint:disable:member-ordering component-selector */\n/**\n * Component providing an input field for searching MatSelect options.\n *\n * Example usage:\n *\n * interface Bank {\n *  id: string;\n *  name: string;\n * }\n *\n * @Component({\n *   selector: 'my-app-data-selection',\n *   template: `\n *     <mat-form-field>\n *       <mat-select [formControl]=\"bankCtrl\" placeholder=\"Bank\">\n *         <mat-option>\n *           <ngx-mat-select-search [formControl]=\"bankFilterCtrl\"></ngx-mat-select-search>\n *         </mat-option>\n *         <mat-option *ngFor=\"let bank of filteredBanks | async\" [value]=\"bank.id\">\n *           {{bank.name}}\n *         </mat-option>\n *       </mat-select>\n *     </mat-form-field>\n *   `\n * })\n * export class DataSelectionComponent implements OnInit, OnDestroy {\n *\n *   // control for the selected bank\n *   public bankCtrl: FormControl = new FormControl();\n *   // control for the MatSelect filter keyword\n *   public bankFilterCtrl: FormControl = new FormControl();\n *\n *   // list of banks\n *   private banks: Bank[] = [{name: 'Bank A', id: 'A'}, {name: 'Bank B', id: 'B'}, {name: 'Bank C', id: 'C'}];\n *   // list of banks filtered by search keyword\n *   public filteredBanks: ReplaySubject<Bank[]> = new ReplaySubject<Bank[]>(1);\n *\n *   // Subject that emits when the component has been destroyed.\n *   private _onDestroy = new Subject<void>();\n *\n *\n *   ngOnInit() {\n *     // load the initial bank list\n *     this.filteredBanks.next(this.banks.slice());\n *     // listen for search field value changes\n *     this.bankFilterCtrl.valueChanges\n *       .pipe(takeUntil(this._onDestroy))\n *       .subscribe(() => {\n *         this.filterBanks();\n *       });\n *   }\n *\n *   ngOnDestroy() {\n *     this._onDestroy.next();\n *     this._onDestroy.complete();\n *   }\n *\n *   private filterBanks() {\n *     if (!this.banks) {\n *       return;\n *     }\n *\n *     // get the search keyword\n *     let search = this.bankFilterCtrl.value;\n *     if (!search) {\n *       this.filteredBanks.next(this.banks.slice());\n *       return;\n *     } else {\n *       search = search.toLowerCase();\n *     }\n *\n *     // filter the banks\n *     this.filteredBanks.next(\n *       this.banks.filter(bank => bank.name.toLowerCase().indexOf(search) > -1)\n *     );\n *   }\n * }\n */\nlet MatSelectSearchComponent = /*#__PURE__*/(() => {\n  class MatSelectSearchComponent {\n    constructor(matSelect, changeDetectorRef, _viewportRuler, matOption, matFormField, defaultOptions) {\n      this.matSelect = matSelect;\n      this.changeDetectorRef = changeDetectorRef;\n      this._viewportRuler = _viewportRuler;\n      this.matOption = matOption;\n      this.matFormField = matFormField;\n      /** Label of the search placeholder */\n      this.placeholderLabel = 'Suche';\n      /** Type of the search input field */\n      this.type = 'text';\n      /** Font-based icon used for displaying Close-Icon */\n      this.closeIcon = 'close';\n      /** Label to be shown when no entries are found. Set to null if no message should be shown. */\n      this.noEntriesFoundLabel = 'Keine Optionen gefunden';\n      /**\n        * Whether the search field should be cleared after the dropdown menu is closed.\n        * Useful for server-side filtering. See [#3](https://github.com/bithost-gmbh/ngx-mat-select-search/issues/3)\n        */\n      this.clearSearchInput = true;\n      /** Whether to show the search-in-progress indicator */\n      this.searching = false;\n      /** Disables initial focusing of the input field */\n      this.disableInitialFocus = false;\n      /** Enable clear input on escape pressed */\n      this.enableClearOnEscapePressed = false;\n      /**\n       * Prevents home / end key being propagated to mat-select,\n       * allowing to move the cursor within the search input instead of navigating the options\n       */\n      this.preventHomeEndKeyPropagation = false;\n      /** Disables scrolling to active options when option list changes. Useful for server-side search */\n      this.disableScrollToActiveOnOptionsChanged = false;\n      /** Adds 508 screen reader support for search box */\n      this.ariaLabel = 'dropdown search';\n      /** Whether to show Select All Checkbox (for mat-select[multi=true]) */\n      this.showToggleAllCheckbox = false;\n      /** Select all checkbox checked state */\n      this.toggleAllCheckboxChecked = false;\n      /** select all checkbox indeterminate state */\n      this.toggleAllCheckboxIndeterminate = false;\n      /** Display a message in a tooltip on the toggle-all checkbox */\n      this.toggleAllCheckboxTooltipMessage = '';\n      /** Define the position of the tooltip on the toggle-all checkbox. */\n      this.toggleAllCheckboxTooltipPosition = 'below';\n      /** Show/Hide the search clear button of the search input */\n      this.hideClearSearchButton = false;\n      /**\n       * Always restore selected options on selectionChange for mode multi (e.g. for lazy loading/infinity scrolling).\n       * Defaults to false, so selected options are only restored while filtering is active.\n       */\n      this.alwaysRestoreSelectedOptionsMulti = false;\n      /**\n       * Recreate array of selected values for multi-selects.\n       *\n       * This is useful if the selected values are stored in an immutable data structure.\n       */\n      this.recreateValuesArray = false;\n      /** Output emitter to send to parent component with the toggle all boolean */\n      this.toggleAll = new EventEmitter();\n      this.onTouched = _ => {};\n      this._options$ = new BehaviorSubject(null);\n      this.optionsList$ = this._options$.pipe(switchMap(_options => _options ? _options.changes.pipe(map(options => options.toArray()), startWith(_options.toArray())) : of(null)));\n      this.optionsLength$ = this.optionsList$.pipe(map(options => options ? options.length : 0));\n      this._formControl = new FormControl('', {\n        nonNullable: true\n      });\n      /** Whether to show the no entries found message */\n      this._showNoEntriesFound$ = combineLatest([this._formControl.valueChanges, this.optionsLength$]).pipe(map(([value, optionsLength]) => !!(this.noEntriesFoundLabel && value && optionsLength === this.getOptionsLengthOffset())));\n      /** Subject that emits when the component has been destroyed. */\n      this._onDestroy = new Subject();\n      this.applyDefaultOptions(defaultOptions);\n    }\n    /** Current search value */\n    get value() {\n      return this._formControl.value;\n    }\n    /** Reference to the MatSelect options */\n    set _options(_options) {\n      this._options$.next(_options);\n    }\n    get _options() {\n      return this._options$.getValue();\n    }\n    applyDefaultOptions(defaultOptions) {\n      if (!defaultOptions) {\n        return;\n      }\n      for (const key of configurableDefaultOptions) {\n        if (defaultOptions.hasOwnProperty(key)) {\n          this[key] = defaultOptions[key];\n        }\n      }\n    }\n    ngOnInit() {\n      // set custom mat-option class if the component was placed inside a mat-option\n      if (this.matOption) {\n        this.matOption.disabled = true;\n        this.matOption._getHostElement().classList.add('contains-mat-select-search');\n        this.matOption._getHostElement().setAttribute('role', 'presentation');\n      } else {\n        console.error('<ngx-mat-select-search> must be placed inside a <mat-option> element');\n      }\n      // when the select dropdown panel is opened or closed\n      this.matSelect.openedChange.pipe(delay(1), takeUntil(this._onDestroy)).subscribe(opened => {\n        if (opened) {\n          this.updateInputWidth();\n          // focus the search field when opening\n          if (!this.disableInitialFocus) {\n            this._focus();\n          }\n        } else {\n          // clear it when closing\n          if (this.clearSearchInput) {\n            this._reset();\n          }\n        }\n      });\n      // set the first item active after the options changed\n      this.matSelect.openedChange.pipe(take(1), switchMap(_ => {\n        this._options = this.matSelect.options;\n        // Closure variable for tracking the most recent first option.\n        // In order to avoid causing the list to\n        // scroll to the top when options are added to the bottom of\n        // the list (eg: infinite scroll), we compare only\n        // the changes to the first options to determine if we\n        // should set the first item as active.\n        // This prevents unnecessary scrolling to the top of the list\n        // when options are appended, but allows the first item\n        // in the list to be set as active by default when there\n        // is no active selection\n        let previousFirstOption = this._options.toArray()[this.getOptionsLengthOffset()];\n        return this._options.changes.pipe(tap(() => {\n          // avoid \"expression has been changed\" error\n          setTimeout(() => {\n            // Convert the QueryList to an array\n            const options = this._options.toArray();\n            // The true first item is offset by 1\n            const currentFirstOption = options[this.getOptionsLengthOffset()];\n            const keyManager = this.matSelect._keyManager;\n            if (keyManager && this.matSelect.panelOpen && currentFirstOption) {\n              // set first item active and input width\n              // Check to see if the first option in these changes is different from the previous.\n              const firstOptionIsChanged = !previousFirstOption || !this.matSelect.compareWith(previousFirstOption.value, currentFirstOption.value);\n              // CASE: The first option is different now.\n              // Indicates we should set it as active and scroll to the top.\n              if (firstOptionIsChanged || !keyManager.activeItem || !options.find(option => this.matSelect.compareWith(option.value, keyManager.activeItem?.value))) {\n                keyManager.setActiveItem(this.getOptionsLengthOffset());\n              }\n              // wait for panel width changes\n              setTimeout(() => {\n                this.updateInputWidth();\n              });\n            }\n            // Update our reference\n            previousFirstOption = currentFirstOption;\n          });\n        }));\n      })).pipe(takeUntil(this._onDestroy)).subscribe();\n      // add or remove css class depending on whether to show the no entries found message\n      // note: this is hacky\n      this._showNoEntriesFound$.pipe(takeUntil(this._onDestroy)).subscribe(showNoEntriesFound => {\n        // set no entries found class on mat option\n        if (this.matOption) {\n          if (showNoEntriesFound) {\n            this.matOption._getHostElement().classList.add('mat-select-search-no-entries-found');\n          } else {\n            this.matOption._getHostElement().classList.remove('mat-select-search-no-entries-found');\n          }\n        }\n      });\n      // resize the input width when the viewport is resized, i.e. the trigger width could potentially be resized\n      this._viewportRuler.change().pipe(takeUntil(this._onDestroy)).subscribe(() => {\n        if (this.matSelect.panelOpen) {\n          this.updateInputWidth();\n        }\n      });\n      this.initMultipleHandling();\n      this.optionsList$.pipe(takeUntil(this._onDestroy)).subscribe(() => {\n        // update view when available options change\n        this.changeDetectorRef.markForCheck();\n      });\n    }\n    _emitSelectAllBooleanToParent(state) {\n      this.toggleAll.emit(state);\n    }\n    ngOnDestroy() {\n      this._onDestroy.next();\n      this._onDestroy.complete();\n    }\n    _isToggleAllCheckboxVisible() {\n      return this.matSelect.multiple && this.showToggleAllCheckbox;\n    }\n    /**\n     * Handles the key down event with MatSelect.\n     * Allows e.g. selecting with enter key, navigation with arrow keys, etc.\n     * @param event\n     */\n    _handleKeydown(event) {\n      // Prevent propagation for all alphanumeric characters in order to avoid selection issues\n      // tslint:disable-next-line:max-line-length\n      // Needed to avoid handling in https://github.com/angular/components/blob/5439460d1fe166f8ec34ab7d48f05e0dd7f6a946/src/material/select/select.ts#L965\n      if (event.key && event.key.length === 1 || this.preventHomeEndKeyPropagation && (event.key === 'Home' || event.key === 'End')) {\n        event.stopPropagation();\n      }\n      if (this.matSelect.multiple && event.key && event.key === 'Enter') {\n        // Regain focus after multiselect, so we can further type\n        setTimeout(() => this._focus());\n      }\n      // Special case if click Escape, if input is empty, close the dropdown, if not, empty out the search field\n      if (this.enableClearOnEscapePressed && event.key === 'Escape' && this.value) {\n        this._reset(true);\n        event.stopPropagation();\n      }\n    }\n    /**\n     * Handles the key up event with MatSelect.\n     * Allows e.g. the announcing of the currently activeDescendant by screen readers.\n     */\n    _handleKeyup(event) {\n      if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n        const ariaActiveDescendantId = this.matSelect._getAriaActiveDescendant();\n        const index = this._options.toArray().findIndex(item => item.id === ariaActiveDescendantId);\n        if (index !== -1) {\n          this.unselectActiveDescendant();\n          this.activeDescendant = this._options.toArray()[index]._getHostElement();\n          this.activeDescendant.setAttribute('aria-selected', 'true');\n          this.searchSelectInput.nativeElement.setAttribute('aria-activedescendant', ariaActiveDescendantId);\n        }\n      }\n    }\n    writeValue(value) {\n      this._lastExternalInputValue = value;\n      this._formControl.setValue(value);\n      this.changeDetectorRef.markForCheck();\n    }\n    onBlur() {\n      this.unselectActiveDescendant();\n      this.onTouched();\n    }\n    registerOnChange(fn) {\n      this._formControl.valueChanges.pipe(filter(value => value !== this._lastExternalInputValue), tap(() => this._lastExternalInputValue = undefined), takeUntil(this._onDestroy)).subscribe(fn);\n    }\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * Focuses the search input field\n     */\n    _focus() {\n      if (!this.searchSelectInput || !this.matSelect.panel) {\n        return;\n      }\n      // save and restore scrollTop of panel, since it will be reset by focus()\n      // note: this is hacky\n      const panel = this.matSelect.panel.nativeElement;\n      const scrollTop = panel.scrollTop;\n      // focus\n      this.searchSelectInput.nativeElement.focus();\n      panel.scrollTop = scrollTop;\n    }\n    /**\n     * Resets the current search value\n     * @param focus whether to focus after resetting\n     */\n    _reset(focus) {\n      this._formControl.setValue('');\n      if (focus) {\n        this._focus();\n      }\n    }\n    /**\n     * Initializes handling <mat-select [multiple]=\"true\">\n     * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.\n     */\n    initMultipleHandling() {\n      if (!this.matSelect.ngControl) {\n        if (this.matSelect.multiple) {\n          // note: the access to matSelect.ngControl (instead of matSelect.value / matSelect.valueChanges)\n          // is necessary to properly work in multi-selection mode.\n          console.error('the mat-select containing ngx-mat-select-search must have a ngModel or formControl directive when multiple=true');\n        }\n        return;\n      }\n      // if <mat-select [multiple]=\"true\">\n      // store previously selected values and restore them when they are deselected\n      // because the option is not available while we are currently filtering\n      this.previousSelectedValues = this.matSelect.ngControl.value;\n      if (!this.matSelect.ngControl.valueChanges) {\n        return;\n      }\n      this.matSelect.ngControl.valueChanges.pipe(takeUntil(this._onDestroy)).subscribe(values => {\n        let restoreSelectedValues = false;\n        if (this.matSelect.multiple) {\n          if ((this.alwaysRestoreSelectedOptionsMulti || this._formControl.value && this._formControl.value.length) && this.previousSelectedValues && Array.isArray(this.previousSelectedValues)) {\n            if (!values || !Array.isArray(values)) {\n              values = [];\n            }\n            const optionValues = this.matSelect.options.map(option => option.value);\n            this.previousSelectedValues.forEach(previousValue => {\n              if (!values.some(v => this.matSelect.compareWith(v, previousValue)) && !optionValues.some(v => this.matSelect.compareWith(v, previousValue))) {\n                // if a value that was selected before is deselected and not found in the options, it was deselected\n                // due to the filtering, so we restore it.\n                if (this.recreateValuesArray) {\n                  values = [...values, previousValue];\n                } else {\n                  values.push(previousValue);\n                }\n                restoreSelectedValues = true;\n              }\n            });\n          }\n        }\n        this.previousSelectedValues = values;\n        if (restoreSelectedValues) {\n          this.matSelect._onChange(values);\n        }\n      });\n    }\n    /**\n     *  Set the width of the innerSelectSearch to fit even custom scrollbars\n     *  And support all Operating Systems\n     */\n    updateInputWidth() {\n      if (!this.innerSelectSearch || !this.innerSelectSearch.nativeElement) {\n        return;\n      }\n      let element = this.innerSelectSearch.nativeElement;\n      let panelElement = null;\n      while (element && element.parentElement) {\n        element = element.parentElement;\n        if (element.classList.contains('mat-select-panel')) {\n          panelElement = element;\n          break;\n        }\n      }\n      if (panelElement) {\n        this.innerSelectSearch.nativeElement.style.width = panelElement.clientWidth + 'px';\n      }\n    }\n    /**\n     * Determine the offset to length that can be caused by the optional matOption used as a search input.\n     */\n    getOptionsLengthOffset() {\n      if (this.matOption) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n    unselectActiveDescendant() {\n      this.activeDescendant?.removeAttribute('aria-selected');\n      this.searchSelectInput.nativeElement.removeAttribute('aria-activedescendant');\n    }\n  }\n  MatSelectSearchComponent.ɵfac = function MatSelectSearchComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || MatSelectSearchComponent)(i0.ɵɵdirectiveInject(MatSelect), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.ViewportRuler), i0.ɵɵdirectiveInject(MatOption, 8), i0.ɵɵdirectiveInject(MatFormField, 8), i0.ɵɵdirectiveInject(MAT_SELECTSEARCH_DEFAULT_OPTIONS, 8));\n  };\n  MatSelectSearchComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatSelectSearchComponent,\n    selectors: [[\"ngx-mat-select-search\"]],\n    contentQueries: function MatSelectSearchComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, MatSelectSearchClearDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, MatSelectNoEntriesFoundDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearIcon = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noEntriesFound = _t.first);\n      }\n    },\n    viewQuery: function MatSelectSearchComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7, ElementRef);\n        i0.ɵɵviewQuery(_c1, 7, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchSelectInput = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.innerSelectSearch = _t.first);\n      }\n    },\n    inputs: {\n      placeholderLabel: \"placeholderLabel\",\n      type: \"type\",\n      closeIcon: \"closeIcon\",\n      closeSvgIcon: \"closeSvgIcon\",\n      noEntriesFoundLabel: \"noEntriesFoundLabel\",\n      clearSearchInput: \"clearSearchInput\",\n      searching: \"searching\",\n      disableInitialFocus: \"disableInitialFocus\",\n      enableClearOnEscapePressed: \"enableClearOnEscapePressed\",\n      preventHomeEndKeyPropagation: \"preventHomeEndKeyPropagation\",\n      disableScrollToActiveOnOptionsChanged: \"disableScrollToActiveOnOptionsChanged\",\n      ariaLabel: \"ariaLabel\",\n      showToggleAllCheckbox: \"showToggleAllCheckbox\",\n      toggleAllCheckboxChecked: \"toggleAllCheckboxChecked\",\n      toggleAllCheckboxIndeterminate: \"toggleAllCheckboxIndeterminate\",\n      toggleAllCheckboxTooltipMessage: \"toggleAllCheckboxTooltipMessage\",\n      toggleAllCheckboxTooltipPosition: \"toggleAllCheckboxTooltipPosition\",\n      hideClearSearchButton: \"hideClearSearchButton\",\n      alwaysRestoreSelectedOptionsMulti: \"alwaysRestoreSelectedOptionsMulti\",\n      recreateValuesArray: \"recreateValuesArray\"\n    },\n    outputs: {\n      toggleAll: \"toggleAll\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => MatSelectSearchComponent),\n      multi: true\n    }])],\n    ngContentSelectors: _c3,\n    decls: 13,\n    vars: 14,\n    consts: [[\"innerSelectSearch\", \"\"], [\"searchSelectInput\", \"\"], [\"defaultIcon\", \"\"], [\"defaultNoEntriesFound\", \"\"], [\"matInput\", \"\", 1, \"mat-select-search-input\", \"mat-select-search-hidden\"], [1, \"mat-select-search-inner\", \"mat-typography\", \"mat-datepicker-content\", \"mat-tab-header\", 3, \"ngClass\"], [1, \"mat-select-search-inner-row\"], [\"class\", \"mat-select-search-toggle-all-checkbox\", \"matTooltipClass\", \"ngx-mat-select-search-toggle-all-tooltip\", 3, \"color\", \"checked\", \"indeterminate\", \"matTooltip\", \"matTooltipPosition\", \"change\", 4, \"ngIf\"], [\"autocomplete\", \"off\", 1, \"mat-select-search-input\", 3, \"keydown\", \"keyup\", \"blur\", \"type\", \"formControl\", \"placeholder\"], [\"class\", \"mat-select-search-spinner\", \"diameter\", \"16\", 4, \"ngIf\"], [\"mat-icon-button\", \"\", \"aria-label\", \"Clear\", \"class\", \"mat-select-search-clear\", 3, \"click\", 4, \"ngIf\"], [\"class\", \"mat-select-search-no-entries-found\", 4, \"ngIf\"], [\"matTooltipClass\", \"ngx-mat-select-search-toggle-all-tooltip\", 1, \"mat-select-search-toggle-all-checkbox\", 3, \"change\", \"color\", \"checked\", \"indeterminate\", \"matTooltip\", \"matTooltipPosition\"], [\"diameter\", \"16\", 1, \"mat-select-search-spinner\"], [\"mat-icon-button\", \"\", \"aria-label\", \"Clear\", 1, \"mat-select-search-clear\", 3, \"click\"], [4, \"ngIf\", \"ngIfElse\"], [3, \"svgIcon\"], [1, \"mat-select-search-no-entries-found\"]],\n    template: function MatSelectSearchComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r1 = i0.ɵɵgetCurrentView();\n        i0.ɵɵprojectionDef(_c2);\n        i0.ɵɵelement(0, \"input\", 4);\n        i0.ɵɵelementStart(1, \"div\", 5, 0)(3, \"div\", 6);\n        i0.ɵɵtemplate(4, MatSelectSearchComponent_mat_checkbox_4_Template, 1, 5, \"mat-checkbox\", 7);\n        i0.ɵɵelementStart(5, \"input\", 8, 1);\n        i0.ɵɵlistener(\"keydown\", function MatSelectSearchComponent_Template_input_keydown_5_listener($event) {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(ctx._handleKeydown($event));\n        })(\"keyup\", function MatSelectSearchComponent_Template_input_keyup_5_listener($event) {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(ctx._handleKeyup($event));\n        })(\"blur\", function MatSelectSearchComponent_Template_input_blur_5_listener() {\n          i0.ɵɵrestoreView(_r1);\n          return i0.ɵɵresetView(ctx.onBlur());\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, MatSelectSearchComponent_mat_spinner_7_Template, 1, 0, \"mat-spinner\", 9)(8, MatSelectSearchComponent_button_8_Template, 4, 2, \"button\", 10);\n        i0.ɵɵprojection(9);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(10, \"mat-divider\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(11, MatSelectSearchComponent_div_11_Template, 4, 2, \"div\", 11);\n        i0.ɵɵpipe(12, \"async\");\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(11, _c4, ctx.matSelect.multiple, ctx._isToggleAllCheckboxVisible()));\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx._isToggleAllCheckboxVisible());\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"type\", ctx.type)(\"formControl\", ctx._formControl)(\"placeholder\", ctx.placeholderLabel);\n        i0.ɵɵattribute(\"aria-label\", ctx.ariaLabel);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.searching);\n        i0.ɵɵadvance();\n        i0.ɵɵproperty(\"ngIf\", !ctx.hideClearSearchButton && ctx.value && !ctx.searching);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(12, 9, ctx._showNoEntriesFound$));\n      }\n    },\n    dependencies: [i2.NgClass, i2.NgIf, i3.DefaultValueAccessor, i3.NgControlStatus, i3.FormControlDirective, i4.MatIconButton, i5.MatCheckbox, i6.MatIcon, i7.MatProgressSpinner, i8.MatTooltip, i9.MatDivider, i2.AsyncPipe],\n    styles: [\".mat-select-search-hidden[_ngcontent-%COMP%]{visibility:hidden}.mat-select-search-inner[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;z-index:100;font-size:inherit;box-shadow:none;background-color:var(--mat-select-panel-background-color)}.mat-select-search-inner.mat-select-search-inner-multiple.mat-select-search-inner-toggle-all[_ngcontent-%COMP%]   .mat-select-search-inner-row[_ngcontent-%COMP%]{display:flex;align-items:center}.mat-select-search-input[_ngcontent-%COMP%]{box-sizing:border-box;width:100%;border:none;font-family:inherit;font-size:inherit;color:currentColor;outline:none;background-color:var(--mat-select-panel-background-color);padding:0 44px 0 16px;height:calc(3em - 1px);line-height:calc(3em - 1px)}[dir=rtl][_nghost-%COMP%]   .mat-select-search-input[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-input[_ngcontent-%COMP%]{padding-right:16px;padding-left:44px}.mat-select-search-input[_ngcontent-%COMP%]::-moz-placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color)}.mat-select-search-input[_ngcontent-%COMP%]::placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color)}.mat-select-search-inner-toggle-all[_ngcontent-%COMP%]   .mat-select-search-input[_ngcontent-%COMP%]{padding-left:5px}.mat-select-search-no-entries-found[_ngcontent-%COMP%]{padding-top:8px}.mat-select-search-clear[_ngcontent-%COMP%]{position:absolute;right:4px;top:0}[dir=rtl][_nghost-%COMP%]   .mat-select-search-clear[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-clear[_ngcontent-%COMP%]{right:auto;left:4px}.mat-select-search-spinner[_ngcontent-%COMP%]{position:absolute;right:16px;top:calc(50% - 8px)}[dir=rtl][_nghost-%COMP%]   .mat-select-search-spinner[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-spinner[_ngcontent-%COMP%]{right:auto;left:16px}  .mat-mdc-option[aria-disabled=true].contains-mat-select-search{position:sticky;top:-8px;z-index:1;opacity:1;margin-top:-8px;pointer-events:all}  .mat-mdc-option[aria-disabled=true].contains-mat-select-search .mat-icon{margin-right:0;margin-left:0}  .mat-mdc-option[aria-disabled=true].contains-mat-select-search mat-pseudo-checkbox{display:none}  .mat-mdc-option[aria-disabled=true].contains-mat-select-search .mdc-list-item__primary-text{opacity:1}.mat-select-search-toggle-all-checkbox[_ngcontent-%COMP%]{padding-left:5px}[dir=rtl][_nghost-%COMP%]   .mat-select-search-toggle-all-checkbox[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-toggle-all-checkbox[_ngcontent-%COMP%]{padding-left:0;padding-right:5px}\"],\n    changeDetection: 0\n  });\n  return MatSelectSearchComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Copyright (c) 2018 Bithost GmbH All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MatSelectSearchVersion = '7.0.10';\nlet NgxMatSelectSearchModule = /*#__PURE__*/(() => {\n  class NgxMatSelectSearchModule {}\n  NgxMatSelectSearchModule.ɵfac = function NgxMatSelectSearchModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NgxMatSelectSearchModule)();\n  };\n  NgxMatSelectSearchModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxMatSelectSearchModule\n  });\n  NgxMatSelectSearchModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, ReactiveFormsModule, MatButtonModule, MatCheckboxModule, MatIconModule, MatProgressSpinnerModule, MatTooltipModule, MatDividerModule]\n  });\n  return NgxMatSelectSearchModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_SELECTSEARCH_DEFAULT_OPTIONS, MatSelectNoEntriesFoundDirective, MatSelectSearchClearDirective, MatSelectSearchComponent, MatSelectSearchVersion, NgxMatSelectSearchModule, configurableDefaultOptions };\n//# sourceMappingURL=ngx-mat-select-search.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}